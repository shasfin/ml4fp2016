\chapter{Implementation} \label{ch:implementation}

We implemented our prototype in OCaml 4.03.0, closely following the formalisation in Chapter~\ref{ch:definitions}.  Evaluation, type checking and type unification are implemented on top of an interpreter for our internal language.  A parser for this language was generated with the \lstinline!menhir! package.  The types and the terms of the language are represented by algebraic data types.  For convenience, we use De Bruijn indices \cite{DEBRUIJN1972381} to represent bound variables in term and type abstractions.  In order to speed up the evaluation, we introduce built-in integers and built-in functions.  This allows us to implement arithmetic operations in terms of the OCaml integer arithmetic.

As already discussed in Section~\ref{Term and types}, the internal language supports recursion by name.  In evaluation and type checking we use maps from library components to their (possibly recursive) definitions to unfold the definitions when needed.  For example, to check type equality during type checking we sometimes have to unfold recursive type definitions.

Unification is implemented along the lines of the unification algorithm presented in Section~\ref{Unification}. Constraint sets are represented by lists of pairs and substitutions by hashmaps mapping holes to types. Since we only run small instances, the negative effect on performance caused by this naive implementation is limited.

During synthesis, we represent partial programs as maps from holes to terms (that possibly contain holes as well). Every call to the successor function adds a mapping for the current hole.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
