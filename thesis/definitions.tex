\chapter{Top down type driven synthesis} \label{definitions}

\TODO{starting words}
In this chapter we will present and formally define all concepts and algorithms used by the synthesis system \textsc{Tamandu}.


\section{Problem}
introductory example
consider we want to generate 
\begin{lstlisting}[style=plain, mathescape]
replicate :: $\forall$ X. Int $\rightarrow$ X $\rightarrow$ List X
\end{lstlisting}

\begin{lstlisting}[style=plain, mathescape]
replicate n x = map Int X (const X Int x) (enumTo n)
\end{lstlisting}

\section{System F}
The exposition will closely follow  Pierce \note{cite the book properly}.

  \subsection{Terms and Types}
\begin{itemize}
\item similar to Pierce
\item except holes, components and free variables
\item the search space is not the whole language but only a subset of it
\end{itemize}

Real System F
 \begin{plstx}
(terms): t ::= x | \lambda x : T. t | t\;t | \Lambda X. t | t\;[T]\\
(types): T ::= X | T \rightarrow T | \forall X. T\\
(variable bindings): \Gamma ::= \emptyset | \Gamma \cup x : T\\
\end{plstx}

We use an extension of System F featuring holes $?x$, input variables $i$ as well as named library components $c$ and named types $C$. The use of the names enables recursion in the definition of library components and types. Named types also support type parameters. The number of type parameters supported by a named type is denoted as $K$ in its definition.

Question: where is the output? Can you define input and output pairs?
Our system
 \begin{plstx}
(terms): t ::= x | \lambda x : T. t | t\;t | \Lambda X. t | t\;[T] | c | {?x} | i\\
(types): T ::= X | T \rightarrow T | \forall X. T | ?X | I | C\;[T,\ldots, T]\\
(variable bindings): \Gamma ::= \emptyset | \Gamma \cup x : T | \Gamma \cup X\\
(hole bindings): \Xi ::= \emptyset | \Xi \cup {?x : T} | \Xi \cup {?X}\\
(input variable bindings): \Phi ::= \emptyset | \Phi \cup i = t : T | \Phi \cup I = T : K\\
(library components): \Delta ::= \emptyset | \Delta \cup c = t : T | \Delta \cup C = T : K\\
\end{plstx}

Question: do we need the definitions of library components for synthesis? We use them only for evaluation, but we always evaluate programs during synthesis. Same for the input variables. Actually, for each I/O-example we get the pair $(\Phi,o)$, where $\Phi$ instantiates all input variables and input types of a program and $o$ is the expected output.
Subset of our system that builds the search space
 \begin{plstx}
(terms): t ::= t\;t | t\;[T] | c | ?x | i\\
(types): T ::= X | T \rightarrow T | \forall X. T | ?X | I | C\;[T,\ldots, T]\\
(hole bindings): \Xi ::= \emptyset | \Xi \cup {?x : T} | \Xi \cup {?X}\\
(input variable bindings): \Phi ::= \emptyset | \Phi \cup i = t : T | \Phi \cup I = T : K\\
(library components): \Delta ::= \emptyset | \Delta \cup c = t : T | \Delta \cup C = T : K\\
\end{plstx}


A program is the quadriplet $\{\Xi, \Phi, \Delta \vdash t :: T\}$. 
A term is called \emph{closed} if it does not contain holes.
A program is closed, if $\Xi$ is empty and $t$ and $T$ do not contain holes.

 
  \subsection{Evaluation semantics}

We usually evaluate only closed programs. Eager evaluation. Rules.
  
  
  \subsection{Encodings}
Note that in the definition of types we do not see familiar types such as booleans, integers, lists or trees. All these types can be encoded in System F using either the Church's or the Scott's encoding \cite{ScottNumerals}. We opted for the Scott's encoding because it's more efficient in our case.
Scott's booleans coincide with Church's booleans and are encoded as follows.
\begin{lstlisting}[style=plain, mathescape]
Bool  = $\forall$R. R $\rightarrow$ R $\rightarrow$ R
true  = $\Lambda$R. $\lambda x_1$:R. $\lambda x_2$:R. $x_1$
      : Bool
false = $\Lambda$R. $\lambda x_1$:R. $\lambda x_2$:R. $x_2$
      : Bool
if-then-else = $\Lambda$X. $\lambda$b:Bool. $\lambda$t:X. $\lambda$f:X. b [X] t f
             : $\forall$X. Bool $\rightarrow$ X $\rightarrow$ X $\rightarrow$ X
\end{lstlisting}

Scott's integers differ from Church's integers as they are more suitable for pattern matching. \note{because they don't unwrap the whole integer every time.}
\begin{lstlisting}[style=plain, mathescape]
Int = $\forall$R. R $\rightarrow$ (Int $\rightarrow$ R) $\rightarrow$ R
zero = $\Lambda$R. $\lambda$z:R. $\lambda$s:Int $\rightarrow$ R. z
     : Int
succ = $\lambda$ n:Int. $\Lambda$R. $\lambda$z:R. $\lambda$s:Int $\rightarrow$ R. s n
     : Int $\rightarrow$ Int
case = $\Lambda$R. $\lambda$n:Int. $\lambda$a:R. $\lambda$f:Int $\rightarrow$ R. n [R] a f
     : $\forall$R. Int $\rightarrow$ R $\rightarrow$ (Int $\rightarrow$ R) $\rightarrow$ R
\end{lstlisting}

Analogously, Scott's lists are a recursive type and naturally support pattern matching.
\begin{lstlisting}[style=plain, mathescape]
List X = $\forall$R. R $\rightarrow$ (X $\rightarrow$ List X $\rightarrow$ R) $\rightarrow$ R
nil = $\Lambda$X. $\Lambda$R. $\lambda$n:R. $\lambda$c:X $\rightarrow$ List X $\rightarrow$ R. n
    : $\forall$X. List X
con = $\Lambda$X. $\lambda$x:X. $\lambda$xs:List X. $\Lambda$R. $\lambda$n:R. $\lambda$c:X $\rightarrow$ List X $\rightarrow$ R. c x xs
    : $\forall$X. X $\rightarrow$ List X $\rightarrow$ List X
case = $\Lambda$X. $\Lambda$Y. $\lambda$l:List X. $\lambda$n:Y. $\lambda$c:X $\rightarrow$ List X $\rightarrow$ Y. l [Y] n c
     : $\forall$X. $\forall$Y. List X $\rightarrow$ Y $\rightarrow$ (X $\rightarrow$ List X $\rightarrow$ Y) $\rightarrow$ Y
\end{lstlisting}

 
 
  \subsection{Type unification}
The unification algorithm is based on the unification algorithm for typed lambda calculus from the book of Pierce \TODO{cite the book properly!!!} and slightly modified to fit our needs.
  
  
  \subsection{Type checking}
  

\section{Search}
how do we explore the search space (best-first search).
 (only priority queue)
\subsection{Search space}\label{Search space} (the successor rules)
Use only third system presented in Section System F.

We see the search space as a graph of programs with holes (see third syntax presented in Section System F) where there is an edge between two terms $t_1$ and $t_2$ if and only if the judgement \emph{derive} defined below $\Xi, \Phi, \Delta \vdash t_1 :: T_1 \Mapsto \Xi', \Phi, \Delta \vdash t_2 :: T_2$ holds between the two.

To express the rules in a more compact form, we introduce \emph{evaluation contexts}. An evaluation context is an expression with exactly one syntactic hole $[]$ in which we can plug in any term. For example, if we have the context $\mathcal{E}$ we can place the term $t$ into its hole and denote this new term by $\mathcal{E}[t]$.

A hole $?x$ can be turned into a library component $c$ from the context $\Delta$ or an input variable $i$ from the context $\Phi$. The procedure fresh($T$) transforms universally quantified type variables into fresh type variables $?X$ not used in $\Xi$.
The notation $\sigma(\Delta)$ denotes the application of the substitution $\sigma$ to all types contained in the context $\Delta$.

\begin{prooftree}
\AxiomC{$c : T_c \in \Delta$}
\AxiomC{$\sigma$ unifies $T$ with fresh($T_c$)}
	\RightLabel{D-VarLib}
	\BinaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \sigma(\Xi \setminus \{{?x} : T\}), \Phi, \Delta \vdash c :: \sigma(T) $
	}
\end{prooftree}

\begin{prooftree}
\AxiomC{$i : T_i \in \Phi$}
\AxiomC{$\sigma$ unifies $T$ with fresh($T_i$)}
	\RightLabel{D-VarInp}
	\BinaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \sigma(\Xi \setminus \{{?x} : T\}), \Phi, \Delta \vdash i :: \sigma(T) $
	}
\end{prooftree}

A hole can also be turned into a function application of two new active holes.
\begin{prooftree}
\AxiomC{$?X$ is a fresh type variable}
\AxiomC{$\Xi' = {\Xi \setminus \{?x:T\} \cup \{{?x_1} : {?X} \rightarrow T, {?x_2} : {?X}, {?X}\}}$}
	\RightLabel{D-VarApp}
	\BinaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \Xi', \Phi, \Delta \vdash {?x_1}\;{?x_2} :: T$}
\end{prooftree}

In all other cases we just choose a hole and expand it according to the three rules above.
\begin{prooftree}
\AxiomC{$\Xi, \Phi, \Delta \vdash {?x} :: T_1 \Mapsto \Xi', \Phi, \Delta \vdash t_1' :: T_1'$}
	\RightLabel{D-App}
	\UnaryInfC{$\Xi, \Phi, \Delta \vdash t[{?x}] :: T \Mapsto \Xi', \Phi, \Delta \vdash t[t_1] :: T[T_1/T_1']$}
\end{prooftree}

Note that the types of all successor programs unify with the types of their ancestors. Thus, the search is type directed.


\subsection{Exploration}
  \note{Write also about stack vs queue of open holes}

We explore the search graph using a best first search.
We can play with the algorithm in two points (marked in blue): first, we can define which hole to expand first, second, we can choose the compare function of the priority queue.

\begin{algorithm}
\caption{Best first search}
\KwIn{goal type $T$, library components $\Delta$, list of input-output examples $[(\Phi_1, o_1), \ldots , (\Phi_N, o_N)]$}

queue $\gets$ PriorityQueue.empty {\color{blue}compare}\\
queue $\gets$ PriorityQueue.push queue $\{\Xi, \Phi_1, \Delta \vdash {?x} :: T\}$\\

\While{not ((PriorityQueue.top queue) satisfies all I/O-examples)}{
	successors $\gets$ {\color{blue}successor} (PriorityQueue.top queue)\\
	queue $\gets$ PriorityQueue.pop queue\\
	\For{all s in successors}{
		queue $\gets$ PrioriryQueue.push queue s\\
	}
}
\KwOut{PriorityQueue.top queue}
\end{algorithm}

\section{Cost functions}
  \subsection{nof-nodes}
  \subsection{nof-nodes-simple-type}
  \subsection{no-same-component}
  \subsection{length of the string}

\section{Black list}
  \note{automatic generation of black list discussed in evaluation}
A black list is a list of terms. Programs containing a black term as a subterm are not allowed to have successors. Thus, the algorithm above is modified as follows.

\begin{algorithm}
\caption{Best first search with black list}
\KwIn{goal type $T$, library components $\Delta$, list of input-output examples $[(\Phi_1, o_1), \ldots , (\Phi_N, o_N)]$, black list $[b_1, \ldots , b_M]$}

queue $\gets$ PriorityQueue.empty compare\\
queue $\gets$ PriorityQueue.push queue $\{\Xi, \Phi_1, \Delta \vdash {?x} :: T\}$\\

\While{not ((PriorityQueue.top queue) satisfies all I/O-examples)}{
	\uIf{{\color{blue}not ((PriorityQueue.top queue) contains subterm from black list)}}{
		successors $\gets$ successor (PriorityQueue.top queue)\\
		queue $\gets$ PriorityQueue.pop queue\\
		\For{all s in successors}{
			queue $\gets$ PrioriryQueue.push queue s\\
		}
	}\Else{
		queue $\gets$ PriorityQueue.pop queue\\
	}
}
\KwOut{PriorityQueue.top queue}
\end{algorithm}


\section{Templates}
  Top-down type-driven synthesis.

A template is a program with holes. We are interested in templates where all higher-order components are fixed and there are holes for the first-order components.
The search space is thus similar to the search space described in \ref{Search space}, with the exception that $\Delta$ contains only the higher-order components.
One of the new things are \emph{closed holes} $\underline{?x}$. Those are holes that are supposed to be filled in later with first-order components.

The idea behind the templates is that once the higher-order components are fixed, it should be easy and fast to find a first-order assignment to get the right program. So we could do a limited search from a template and if we do not find a program satisfying all of the I/O-examples we can move quickly to the next template.
  
  \subsection{Successor rules}

The successor rules are very similar to the ones defined in \ref{Search space}, apart from little modifications. That is, now we have a successor rule to close a hole, and we can not instantiate a hole with an input variable any more, because that is supposed to be done in the next step.

So we can \emph{close} a hole.
\begin{prooftree}
\AxiomC{$T$ is a type a first-order component can have}
	\RightLabel{D-VarClose}
	\UnaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \Xi, \Phi, \Delta \vdash {\underline{?x}} :: T$}
\end{prooftree}

We can instantiate a hole with a (higher-order) library component.
\begin{prooftree}
\AxiomC{$c : T_c \in \Delta$}
\AxiomC{$\sigma$ unifies $T$ with fresh($T_c$)}
	\RightLabel{D-VarLib}
	\BinaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \sigma(\Xi \setminus \{{?x} : T\}), \Phi, \Delta \vdash c :: \sigma(T) $
	}
\end{prooftree}

We can instantiate a hole with a function application of two fresh holes.
\begin{prooftree}
\AxiomC{$?X$ is a fresh type variable}
\AxiomC{$\Xi' = {\Xi \setminus \{?x:T\} \cup \{{?x_1} : {?X} \rightarrow T, {?x_2} : {?X}, {?X}\}}$}
	\RightLabel{D-VarApp}
	\BinaryInfC{$\Xi, \Phi, \Delta \vdash {?x} :: T \Mapsto \Xi', \Phi, \Delta \vdash {?x_1}\;{?x_2} :: T$}
\end{prooftree}

We can expand one of the holes of the program according to one of the three rules above.
\begin{prooftree}
\AxiomC{$\Xi, \Phi, \Delta \vdash {?x} :: T_1 \Mapsto \Xi', \Phi, \Delta \vdash t_1' :: T_1'$}
	\RightLabel{D-App}
	\UnaryInfC{$\Xi, \Phi, \Delta \vdash t[{?x}] :: T \Mapsto \Xi', \Phi, \Delta \vdash t[t_1] :: T[T_1/T_1']$}
\end{prooftree}

\TODO{just cite the rules, don't copy-paste them, they are exactly the same}
  




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
