\lstset{style=plain}

\chapter{Introduction}\label{ch:introduction}

Program synthesis, also known as automatic programming, is the automatic generation of programs from specifications.

In this thesis we consider inductive synthesis of purely functional programs from components. We specify the desired program through input-output examples, that is pairs of inputs with their corresponding expected outputs. This is an intuitive and simple way to specify programs and makes synthesis more accessible to users with a lower level of expertise.

When solving programming tasks, human programmers rely on prior knowledge of computational patterns. Such well-known computational patterns are reflected by library components, both first- and higher-order. For example, \lstinline!map! corresponds to the transformation of each element of a list according to a function and \lstinline!foldr! easily translates to recursive programs on lists. The program \lstinline!foldr f init xs! corresponds to the following recursive program with ML-style pattern matching.
\begin{lstlisting}[style=plain]
prog xs = match xs with
  | [] -> init
  | (x::xs) -> f x (prog xs)
\end{lstlisting}
The goal of this thesis is to assess how well the information encoded by such library components can be reused by an automatic synthesiser.
We restrict the space of target programs to straight-line functional programs composed from library components. We do not consider the synthesis of lambda expressions, recursive functions, conditionals and pattern matching.

Program synthesis is an active area of research. Section~\ref{Background} offers a very short and incomplete overview of the area. Closely related work is also shortly discussed in Chapter~\ref{ch:relatedwork}.
We will return to the problem statement of this thesis in Section~\ref{Problem} and state our contributions.

\section{Background}\label{Background}

Program synthesis has been explored at least since the late 60s. Since the problem in its generality is very hard to attack, numerous restrictions have been investigated.

Good results were obtained by restricting the programs being synthesised to a specific domain \cite{Fischer:2003:ASG:967842.967845,Frigo98fftw:an,Thies2002,Gulwani:2011:ASP:1926385.1926423,Gulwani:2011:SGC:1993498.1993505}. Recently a system parametrised by an arbitrary domain-specific language \cite{Perelman:2014:TS:2594291.2594297} was presented. Different instantiations of the domain-specific language produce specific synthesisers for specific domains.

Another way to simplify the problem is explicitly asking the programmer for help, as in \textsc{Sketch} \cite{Solar-Lezama:2006:CSF:1168857.1168907}, where the programmer provides the high-level structure of the program and the synthesiser is asked to fill in the low-level details.

Different approaches has been explored.
Early approaches \cite{Manna:1980:DAP:357084.357090} were based on automatic theorem proving and the Curryâ€“Howard correspondence. A complete logical specification of a program is translated into a theorem and a proof of this theorem is then translated into a program satisfying the specification.
A drawback of these approaches is that a high level of mathematical maturity is required to formulate a specification as a logical formula.

A more accessible specification, which we use in our synthesis procedure, is represented by input-output examples. Two kinds of approaches has been explored with this specification: the first one tries to derive a formula or a set of relations from the input-output examples that can be then transformed into a program \cite{Summers:1977:MLP:321992.322002,Kitzelmann:2009:AIF:1530575.1530582,Jha:2010:OCP:1806799.1806833}; the second one became interesting as the processor speed increased. It is based, like our approach, on enumeration of programs \cite{LambdaSquarePaper,EscherPaper,MythPaper}.

Automatic theorem proving is not the only field that inspired program synthesis. Recently ideas from program verification made their way into synthesis \cite{LeonPaper,DBLP:journals/corr/InalaQLS15,Kuncak:2010:CFS:1806596.1806632}. Type theory also contributes to program synthesis. Recent inductive systems from input-output examples \cite{LambdaSquarePaper,MythPaper} along with our system use simple types to prune the search space. More advanced types are even used as a specification \cite{SynquidPaper}. Because of the advantages offered by input-output examples as a specification, a recent system \cite{Frankle:2016:EST:2837614.2837629} infers those advanced types from input-output examples.

\section{Problem statement}\label{Problem}

\TODO{Describe the problem again, add the replicate example\\}
We restrict ourselves to straight-line functional programs without lambda subexpressions, pattern matching, recursion and conditional but with a large component-library.



Let us move on to the contributions. We implemented in OCaml a prototype\footnote{\TODO{Link to the code?}} of the synthesis procedure we define in Chapter~\ref{ch:definitions}. The main contribution of this thesis is the extensive evaluation of our synthesis tool and the exploration of the search space. The experiments and the findings are presented in Chapter~\ref{ch:evaluation}.

The rest of the thesis is structured as follows. In Chapter~\ref{ch:definitions} the top-down synthesis procedure is introduced and formally defined. Chapter~\ref{ch:implementation} describes how to turn this synthesis procedure into a synthesis tool written in OCaml. In Chapter~\ref{ch:relatedwork} we shortly review four closely related synthesis tools: \textsc{Synquid} \cite{SynquidPaper}, $\lambda^2$ \cite{LambdaSquarePaper}, \textsc{Escher} \cite{EscherPaper} and \textsc{Myth} \cite{MythPaper}. In Chapter~\ref{ch:evaluation} we present the results of the empiric evaluation. Finally, Chapter~\ref{ch:conclusions} draws the conclusions and outlines the possibilities for future work.

---------------------------------


We consider the synthesis of straight-line functional programs from a library of functional components.  For the time being, we would like to further restrict ourselves to purely applicative programs, i.e. programs having no lambda subexpressions.  In principle, these restrictions do not limit program expressivity because adding a suitable higher-order definitions to the library allows one to express all computable functions.


The approach that we would like to explore is an inductive, examples-based program synthesis, but one that incorporates a limited form of deductive inference, in order to prune the program search space. 

The main task of the project is to design and implement an algorithm for program synthesis from a library of computational concepts represented as first or higher-order pure functions.  This requires implementing a small inductive program synthesis framework in which experimentation should be carried in.  As a starting point we suggest implementing a synthesis algorithm based on program enumeration.

 In order to avoid synthesizing programs having errors due to bad typing we assume all the library components are explicitly typed in the Hindley-Milner type system.  From them the synthesizer should build a well-typed program.

Once a basic implementation is done, extensive experimentation should be carried out.

Inductive program synthesis strives to automatically derive a program from a finite set of examples what the program should do.  When solving such tasks humans rely on prior knowledge of well-known computational patterns. The goal of this project is to study how an inductive synthesis algorithm can effectively apply such knowledge in a synthesis task. In particular, higher-order functions represent well-known patterns and we are interested in how a library of such function definitions can be used to guide and speed up the synthesis process.

The goal of the project is to design an inductive synthesis algorithm for the first-order $\lambda$-free expressions of System F. A synthesis task specifies a library of components and a set of input-output examples. The algorithm should compose a subset of the components into an expression that reproduces the input-output examples, and moreover, generalizes well to unseen examples.

\section{Problem}
We restrict ourselves to purely functional programs without pattern matching, without recursion, without conditionals, just application of library components and input variables. Handle many components. Reuse common knowledge. Computational patterns encoded as components.
The main task of the project is to design and implement an algorithm for program synthesis from a library of computational concepts represented as first or higher-order pure functions.
We consider the synthesis of straight-line functional programs from a library of functional components.  For the time being, we would like to further restrict ourselves to purely applicative programs, i.e. programs having no lambda subexpressions. In principle, these restrictions do not limit program expressivity because adding a suitable higher-order definitions to the library allows one to express all computable functions.  In order to avoid synthesizing programs having errors due to bad typing we assume all the library components are explicitly typed in the Hindley-Milner type system.  From them the synthesizer should build a well-typed program.






----------------------------------

\begin{itemize}
\item (maybe move general introduction/motivation to the beginning? State your problem as early as possbible!)
\item intuitive description of the problem statement and a motivation why something that restricted should be interesting (encode computational patterns as components, thin interfaces, SKI as components). Bring the replicate example. Type-driven, example-based, from components. Should be stated clearly. "How I restrict the search space and what specification do I choose. Replicate example. Motivate why it could be useful and why this is not too restricted." Don't forget the main hypothesis, that higher-order components help.
\end{itemize} 


This is not really a limitation, since common recursive patterns can be encoded as components. For example, the program \lstinline!p n = foldNatNat f init n! can be translated into the recursive program
\TODO{Make sure it is \lstinline!f (n-1) (p (n-1))! and not \lstinline!f n (p (n-1))!, correct if needed\\}
\begin{lstlisting}[style=plain]
p n = match n with
  | 0 -> init
  | n -> f (n-1) (p (n-1))
\end{lstlisting}  

for motivation you could write something about the extremely restricted list library in ocaml :)\\
Consider you are writing code in a functional programming language with a smaller choice of library functions than you are used to. For example (true story), if you are using OCaml and you are surprised that \lstinline?replicate? is missing even in the more complete core library \note{cite jane street core}, you could spend a couple of minutes writing your recursive version of \lstinline?replicate?. Or you can synthesize it with \textsc{Tamandu} in less than one second from other components. \TODO{rewrite without 'you' and maybe don't mention ocaml, core and all that thing?}.

input-output examples are an intuitive and simple way to specify programs and make synthesis more accessible to users with a lower level of expertise.


Problem definition: have many components, put them together into a program, no lambdas, no if-then-else, no recursion
  

  
  
Contributions: Evaluation, exploring the baseline algorithm, exploring the search space, see if higher-order components are a good way to communicate knowledge.
