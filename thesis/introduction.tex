\lstset{style=plain}

\chapter{Introduction}\label{ch:introduction}
Program synthesis strives to automatically synthesise programs given some sort of specification of their behaviour.   For example, a specification can be a logical formula that completely describes the relation between program inputs and outputs.  Another popular way is to provide a few concrete input-output examples, and then ask the synthesiser for a program that extrapolates them well.  Compared to precise logical specifications, concrete examples are very attractive, because they are more intuitive and require less effort.  Program Synthesis in this form is the focus of the present thesis.

When solving programming tasks, human programmers invariably rely on prior knowledge in form of computational patterns.  Well-known patterns are typically reflected by libraries of reusable components (subprograms).  For example, the \lstinline!map! higher-order function expresses the transformation of each element of a list according to a given mapping.  The \lstinline!foldr! combinator captures primitive recursion on lists: \lstinline!foldr f init xs! is equivalent to \lstinline!g xs!, where \lstinline!g! is defined by the recursive scheme\footnote{Here and in the following we use improvised Haskell-like syntax.}
\begin{lstlisting}[style=plain]
g [] = init
g (x:xs) = f x (g xs)
\end{lstlisting}

The main goal of the thesis is to investigate whether the computational knowledge encoded by such components can help an automatic synthesiser, analogously to how a human reuses known patterns in order to solve such tasks.  In particular, we investigate whether one can quickly synthesise solutions to basic algorithmic tasks in terms of standard library components.  Our main hypothesis is that standard components capture widely useful patterns that one can use to find short and simple solution programs.

Towards this goal, we develop an examples-based synthesis algorithm, not tailored to a specific set of components.  This allows one to easily expand the ``computational knowledge'' of the synthesiser simply by adding new components.  To simplify the matter, we focus on the synthesis of purely functional programs without any lambda expressions, explicit recursion or conditionals (i.e., only function application is allowed).  This restriction is inessential as richer constructs can be easily simulated by applications of suitable higher-order components.  But importantly, it allows for a clean synthesis algorithm that focuses on how to combine components effectively.

For example, consider we want to generate \lstinline!replicate!, that is the function that takes an integer \lstinline!n! and an element \lstinline!x! of any type and returns the list consisting of \lstinline!n! copies of \lstinline!x!. We expect our synthesiser to output the program:
\begin{lstlisting}[style=plain]
replicate n x = map (const x) (enumTo n)
\end{lstlisting}
In the above program, \lstinline!const! is the function that takes two arguments and always returns the first one; \lstinline!enumTo! is the function that takes an integer \lstinline!m! and returns the list \lstinline![1, 2, $\ldots$, m]!.
The synthesised solution encodes the insight: in order to generate a list consisting of \lstinline!n! copies of \lstinline!x!, one can first generate a list of length \lstinline!n!, in this case \lstinline![1, 2, $\ldots$, n]!, and then map each element to \lstinline!x!.

\section{Existing work}\label{Background}
The past $50$ years of research approached program synthesis from various points of view.  For example, early methods \cite{Manna:1980:DAP:357084.357090} were based on automatic theorem proving and the relation between proofs and programs (the Curryâ€“ Howard correspondence).  They convert a logical specification of a program into a theorem, find a proof of this theorem, and then extract a program from the proof.  Such methods are mainly limited by the performance of the employed theorem prover (which, unfortunately, is not much at present).  A drawback of these approaches is that a high level of mathematical maturity is required to provide the needed logical specification.

A more accessible way to specify a program is by giving a finite number of input-output examples that the synthesised program must satisfy.  In this setting, two main approaches are most popular.  The first one analyses the input-output examples to derive a set of relations that capture them, and then transforms this description into a program \cite{Summers:1977:MLP:321992.322002,Kitzelmann:2009:AIF:1530575.1530582,Jha:2010:OCP:1806799.1806833}.  Even though the techniques are quite interesting, they need much more advancement.  The second one is based on program enumeration \cite{LambdaSquarePaper,EscherPaper,MythPaper}, and became more popular as the processor speed increased.

Good results for the second approach were obtained by restricting the target programs to a specific domain \cite{Gulwani:2011:ASP:1926385.1926423,Gulwani:2011:SGC:1993498.1993505}. Recently a generic system for synthesis in domain-specific languages~\cite{Perelman:2014:TS:2594291.2594297} was presented.  This system gives a lot of flexibility to make the synthesis more tractable by employing more restrictive languages.  Another way to restrict the problem is to require the user for additional clues, as in \textsc{Sketch} \cite{Solar-Lezama:2006:CSF:1168857.1168907}, where the user sketches the high-level structure of the program, while the synthesiser fills in the low-level details.  To achieve efficiency, \textsc{Sketch} combines program enumeration with constraint-satisfaction, for which it uses off-the-shelf SAT/SMT solvers.

Recently, type theory and program verification also entered the synthesis scene \cite{LeonPaper,DBLP:journals/corr/InalaQLS15,Kuncak:2010:CFS:1806596.1806632,Frankle:2016:EST:2837614.2837629}.  Systems like \cite{LambdaSquarePaper,MythPaper,SynquidPaper} actively use type signatures to prune the search space.  This is quite reasonable, as type information is easy to provide and usually readily available.  Also, type-based pruning is essential in our setting, because a large number of library components can often be combined in a small number of ways due to typing.  That is why, our synthesis algorithm also falls into the type-based pruning category.

\section{Contributions}
In this thesis we study whether program synthesis can benefit from access to common computational patterns.  In particular, we investigate whether a library (of first and higher-order components) can guide and speed up the synthesis process.  Towards this end we make the following contributions:

\begin{enumerate}
\item We develop a basic synthesis algorithm for purely functional programs based on exhaustive enumeration combined with type-based pruning.

\item We propose a couple of heuristics to guide the search in a best-first manner, and also how to automatically blacklist certain useless branches.

\item We develop a prototype implementation of our algorithm in OCaml, and perform an extensive evaluation over a library of 37 components.

\item We analyse the results of the evaluation and compare it with reported results from state-of-the-art program synthesis tools.
\end{enumerate}  

Our evaluation indicates that for simple algorithmic problems, our basic algorithm combined with a good enough library of components performs on par with much more sophisticated state of the art algorithms.