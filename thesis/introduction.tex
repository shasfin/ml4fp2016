\lstset{style=plain}

\chapter{Introduction}\label{ch:introduction}

Program synthesis, also known as automatic programming, is the automatic generation of programs from specifications.

In this thesis we consider inductive synthesis of purely functional programs from components. We specify the desired program through input-output examples, that is pairs of inputs with their corresponding expected outputs. This is an intuitive and simple way to specify programs and makes synthesis more accessible to users with a lower level of expertise.

When solving programming tasks, human programmers rely on prior knowledge in form of computational patterns. Such well-known computational patterns are reflected by library components, both first- and higher-order. For example, \lstinline!map! corresponds to the transformation of each element of a list according to a function and \lstinline!foldr! easily translates to recursive programs on lists. The program \lstinline!foldr f init xs! corresponds to the following recursive program. Here and in Section~\ref{Example} we use Haskell-like syntax for programs.
\begin{lstlisting}[style=plain]
prog [] = init
prog (x:xs) = f x (prog xs)
\end{lstlisting}
The goal of this thesis is to assess how well the information encoded by such library components can be reused by an automatic synthesiser.
We restrict the space of target programs to straight-line functional programs composed from library components. We do not consider the synthesis of lambda expressions, recursive functions, conditionals and pattern matching.

Program synthesis is an active area of research. Section~\ref{Background} offers a very short and incomplete overview of the area. Closely related work is also shortly discussed in Chapter~\ref{ch:relatedwork}.
We will return to the problem statement of this thesis in Section~\ref{Problem} and state our contributions.

\section{Background}\label{Background}

Program synthesis has been explored at least since the late 60s. Since the problem in its generality is very hard to attack, numerous restrictions have been investigated.

Good results were obtained by restricting the programs being synthesised to a specific domain \cite{Fischer:2003:ASG:967842.967845,Frigo98fftw:an,Thies2002,Gulwani:2011:ASP:1926385.1926423,Gulwani:2011:SGC:1993498.1993505}. Recently a system parametrised by an arbitrary domain-specific language \cite{Perelman:2014:TS:2594291.2594297} was presented. Different instantiations of the domain-specific language produce specific synthesisers for specific domains.

Another way to simplify the problem is explicitly asking the programmer for help, as in \textsc{Sketch} \cite{Solar-Lezama:2006:CSF:1168857.1168907}, where the programmer provides the high-level structure of the program and the synthesiser is asked to fill in the low-level details.

The approaches explored in the past $50$ years were inspired by different areas of research.
Early approaches \cite{Manna:1980:DAP:357084.357090} were based on automatic theorem proving and the Curry–Howard correspondence. A complete logical specification of a program is translated into a theorem and a proof of this theorem is then translated into a program satisfying the specification.
A drawback of these approaches is that a high level of mathematical maturity is required to formulate a specification as a logical formula.

A more accessible specification, which we use in our synthesis procedure, is represented by input-output examples. Using this specification, two kinds of approaches has been explored: the first one strives to derive a formula or a set of relations from the input-output examples that can be then transformed into a program \cite{Summers:1977:MLP:321992.322002,Kitzelmann:2009:AIF:1530575.1530582,Jha:2010:OCP:1806799.1806833}; the second one, based on program enumeration  \cite{LambdaSquarePaper,EscherPaper,MythPaper}, became popular as the processor speed increased. Our approach is of this kind.

Automatic theorem proving is not the only field that inspired program synthesis. Recently ideas from program verification made their way into synthesis \cite{LeonPaper,DBLP:journals/corr/InalaQLS15,Kuncak:2010:CFS:1806596.1806632}. Type theory also contributes to program synthesis. Recent inductive systems from input-output examples, \cite{LambdaSquarePaper,MythPaper} along with our system, use simple types to prune the search space. More advanced types are even used as a specification \cite{SynquidPaper}. Because of the advantages offered by input-output examples as a specification, a recent system \cite{Frankle:2016:EST:2837614.2837629} infers those advanced types from input-output examples.

\section{Problem statement}\label{Problem}

The synthesis procedure we define and evaluate in this thesis aims to synthesise straight-line purely applicative functional programs specified by input-output examples. We use a simple enumerate-and-test approach. In order to avoid errors due to bad typing, we enumerate only well-typed programs. We rely on a large library of first- and higher-order components reflecting common computational patterns.
The synthesiser should compose a program from library components that agrees with the given input-output examples and generalises well to unseen examples.

For example, consider we want to generate \lstinline!replicate!, the function that takes an integer \lstinline!n! and an element \lstinline!x! of any type and returns the list \lstinline![x, x, $\ldots$, x]! of length \lstinline!n!. A straight-line purely applicative functional solution composed from standard first- and higher-order components would be:
\begin{lstlisting}[style=plain]
replicate n x = map (const x) (enumTo n)
\end{lstlisting}
In the above program, \lstinline!map! is the higher-order function that applies its first argument, a function, to every element of its second argument, a list; \lstinline!const! is the function that takes two arguments and always returns the first one; \lstinline!enumTo! is the function that takes an integer \lstinline!m! and returns the list \lstinline![1, 2, $\ldots$, m]!.
The above program encodes the following insight: in order to generate a list consisting of \lstinline!n! copies of \lstinline!x!, we can first generate a list of length \lstinline!n!, in this case \lstinline![1, 2, $\ldots$, n]!, and then transform each element of this list into \lstinline!x!.

In contrast to other systems based on enumeration \cite{MythPaper, LambdaSquarePaper}, we do not target recursive programs or programs containing lambda expressions, conditionals or pattern matching. However, those restrictions theoretically do not limit the set of functions we can express, since adding suitable higher-order components\footnote{For example, the $S, K, I$ combinators introduced by Schönfinkel in \cite{Schonfinkel1924}.} to the library makes it possible to express all computable functions.

In practice, we can mimic popular recursive patterns with suitable library components. For example, the program \lstinline!p n = foldNat f init n! can be translated into the following recursive program.
\begin{lstlisting}[style=plain]
p 0 = init
p n = f (p (n-1))
\end{lstlisting}
Instantiating \lstinline!init! with \lstinline![]! and \lstinline!f! with \lstinline!(x:)! leads to a solution for \lstinline!replicate! corresponding to the recursive program:
\begin{lstlisting}[style=plain]
replicate 0 x = []
replicate n x = x:(replicate (n-1))
\end{lstlisting}

Analogously, the component \lstinline!foldNatNat! mimics the recursive pattern:
\begin{lstlisting}[style=plain]
p 0 = init
p n = f n (p (n-1))
\end{lstlisting}
This common pattern is used in the recursive definitions of \lstinline!enumTo!, \lstinline!sumUnder! and \lstinline!factorial!.

We are interested in studying how an inductive synthesis algorithm can apply this knowledge in a synthesis task. In particular, we are interested how a library of first- and higher-order components can guide and speed up the synthesis process.
To that end, we implement in OCaml a prototype\footnote{\TODO{Link to the code?}} of the synthesis procedure we define in Chapter~\ref{ch:definitions}. The main contribution of this thesis is the extensive evaluation of our synthesis procedure and the exploration of the search space. The experiments and the findings are presented in Chapter~\ref{ch:evaluation}.

The rest of the thesis is structured as follows. In Chapter~\ref{ch:definitions} the top-down synthesis procedure is introduced and formally defined. Chapter~\ref{ch:implementation} describes how to turn this synthesis procedure into a synthesis tool written in OCaml. In Chapter~\ref{ch:relatedwork} we shortly review four closely related synthesis tools: \textsc{Synquid} \cite{SynquidPaper}, $\lambda^2$ \cite{LambdaSquarePaper}, \textsc{Escher} \cite{EscherPaper} and \textsc{Myth} \cite{MythPaper}. In Chapter~\ref{ch:evaluation} we present the results of the empiric evaluation. Finally, Chapter~\ref{ch:conclusions} draws the conclusions and outlines the possibilities for future work.
